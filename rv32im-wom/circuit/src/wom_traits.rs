//! Write-Once Memory (WOM) traits and frame pointer support for Womir VM
//!
//! This module contains the specialized traits and types needed to support
//! Womir's frame-pointer-based register access model, which differs from
//! standard RISC-V by using write-once memory regions for efficiency in zkVMs.

use std::sync::{Arc, Mutex};

use openvm_circuit::{
    arch::{
        ExecutionState, InstructionExecutor as InstructionExecutorTrait, Result as ResultVm,
        VmAdapterAir, VmAdapterInterface, VmAirWrapper, VmCoreAir,
    },
    system::memory::{MemoryController, OfflineMemory},
    utils::next_power_of_two_or_zero,
};
use openvm_circuit_primitives::AlignedBorrow;
use openvm_instructions::instruction::Instruction;
use openvm_stark_backend::{
    air_builders::{debug::DebugConstraintBuilder, symbolic::SymbolicRapBuilder},
    config::{StarkGenericConfig, Val},
    interaction::{BusIndex, InteractionBuilder, PermutationCheckBus},
    p3_air::BaseAir,
    p3_field::{FieldAlgebra, PrimeField32},
    p3_matrix::dense::RowMajorMatrix,
    p3_maybe_rayon::prelude::*,
    prover::types::AirProofInput,
    rap::{get_air_name, BaseAirWithPublicValues, ColumnsAir},
    AirRef, Chip, ChipUsageGetter,
};
use serde::{de::DeserializeOwned, Deserialize, Serialize};
use struct_reflection::{StructReflection, StructReflectionHelper};

// ============ Frame Bus System ============
// These types manage the frame pointer state transitions in the VM

#[derive(Clone, Copy, Debug)]
pub struct FrameBus {
    pub inner: PermutationCheckBus,
}

impl FrameBus {
    pub const fn new(index: BusIndex) -> Self {
        Self {
            inner: PermutationCheckBus::new(index),
        }
    }

    #[inline(always)]
    pub fn index(&self) -> BusIndex {
        self.inner.index
    }

    /// Caller must constrain that `enabled` is boolean.
    pub fn execute<AB: InteractionBuilder>(
        &self,
        builder: &mut AB,
        enabled: impl Into<AB::Expr>,
        prev_state: FrameState<impl Into<AB::Expr>>,
        next_state: FrameState<impl Into<AB::Expr>>,
    ) {
        let enabled = enabled.into();
        self.inner.receive(
            builder,
            [prev_state.pc.into(), prev_state.fp.into()],
            enabled.clone(),
        );
        self.inner.send(
            builder,
            [next_state.pc.into(), next_state.fp.into()],
            enabled,
        );
    }
}

#[repr(C)]
#[derive(
    Clone, Copy, Debug, PartialEq, Default, AlignedBorrow, Serialize, Deserialize, StructReflection,
)]
pub struct FrameState<T> {
    pub pc: T,
    pub fp: T,
}

impl<T> FrameState<T> {
    pub fn new(pc: impl Into<T>, fp: impl Into<T>) -> Self {
        Self {
            pc: pc.into(),
            fp: fp.into(),
        }
    }

    #[allow(clippy::should_implement_trait)]
    pub fn from_iter<I: Iterator<Item = T>>(iter: &mut I) -> Self {
        let mut next = || iter.next().unwrap();
        Self {
            pc: next(),
            fp: next(),
        }
    }

    pub fn flatten(self) -> [T; 2] {
        [self.pc, self.fp]
    }

    pub fn get_width() -> usize {
        2
    }

    pub fn map<U: Clone, F: Fn(T) -> U>(self, function: F) -> FrameState<U> {
        FrameState::from_iter(&mut self.flatten().map(function).into_iter())
    }
}

#[derive(Copy, Clone, Debug)]
pub struct FrameBridge {
    pub frame_bus: FrameBus,
}

impl FrameBridge {
    pub fn new(frame_bus: FrameBus) -> Self {
        Self { frame_bus }
    }
}

pub struct FrameBridgeInteractor<AB: InteractionBuilder> {
    pub frame_bus: FrameBus,
    pub from_state: FrameState<AB::Expr>,
    pub to_state: FrameState<AB::Expr>,
}

// ============ Wom VM Chip Wrapper ============
// Main wrapper that manages frame pointer state across instruction execution

pub struct VmChipWrapperWom<F, A: VmAdapterChipWom<F>, C: VmCoreChipWom<F, A::Interface>> {
    pub adapter: A,
    pub core: C,
    pub records: Vec<(A::ReadRecord, A::WriteRecord, C::Record)>,
    pub offline_memory: Arc<Mutex<OfflineMemory<F>>>,
    pub fp: Arc<Mutex<u32>>,
}

const DEFAULT_RECORDS_CAPACITY: usize = 1 << 5;

impl<F, A, C> VmChipWrapperWom<F, A, C>
where
    A: VmAdapterChipWom<F>,
    C: VmCoreChipWom<F, A::Interface>,
{
    pub fn new(
        adapter: A,
        core: C,
        offline_memory: Arc<Mutex<OfflineMemory<F>>>,
        fp: Arc<Mutex<u32>>,
    ) -> Self {
        Self {
            adapter,
            core,
            records: Vec::with_capacity(DEFAULT_RECORDS_CAPACITY),
            offline_memory,
            fp,
        }
    }
}

// ============ Wom-specific VM Traits ============
// These traits extend the standard OpenVM traits to support frame pointer operations

/// Adapter trait for Womir VM that includes frame pointer support
pub trait VmAdapterChipWom<F> {
    /// Records generated by adapter before main instruction execution
    type ReadRecord: Send + Serialize + DeserializeOwned;
    /// Records generated by adapter after main instruction execution
    type WriteRecord: Send + Serialize + DeserializeOwned;
    /// AdapterAir should not have public values
    type Air: BaseAir<F> + Clone;

    type Interface: VmAdapterInterface<F>;

    /// Given instruction, perform memory reads and return only the read data that the integrator
    /// needs to use. This is called at the start of instruction execution.
    ///
    /// The implementer may choose to store data in the `Self::ReadRecord` struct, for example in
    /// an [Option], which will later be sent to the `postprocess` method.
    #[allow(clippy::type_complexity)]
    fn preprocess(
        &mut self,
        memory: &mut MemoryController<F>,
        fp: u32,
        instruction: &Instruction<F>,
    ) -> ResultVm<(
        <Self::Interface as VmAdapterInterface<F>>::Reads,
        Self::ReadRecord,
    )>;

    /// Given instruction and the data to write, perform memory writes and return the `(record,
    /// next_timestamp)` of the full adapter record for this instruction. This is guaranteed to
    /// be called after `preprocess`.
    fn postprocess(
        &mut self,
        memory: &mut MemoryController<F>,
        instruction: &Instruction<F>,
        from_state: ExecutionState<u32>,
        from_frame: FrameState<u32>,
        output: AdapterRuntimeContextWom<F, Self::Interface>,
        read_record: &Self::ReadRecord,
    ) -> ResultVm<(ExecutionState<u32>, u32, Self::WriteRecord)>;

    /// Populates `row_slice` with values corresponding to `record`.
    /// The provided `row_slice` will have length equal to `self.air().width()`.
    /// This function will be called for each row in the trace which is being used, and all other
    /// rows in the trace will be filled with zeroes.
    fn generate_trace_row(
        &self,
        row_slice: &mut [F],
        read_record: Self::ReadRecord,
        write_record: Self::WriteRecord,
        memory: &OfflineMemory<F>,
    );

    fn air(&self) -> &Self::Air;
}

/// Runtime context for Womir adapters that includes frame pointer transitions
pub struct AdapterRuntimeContextWom<T, I: VmAdapterInterface<T>> {
    /// Leave as `None` to allow the adapter to decide the `to_pc` automatically.
    pub to_pc: Option<u32>,
    pub to_fp: Option<u32>,
    pub writes: I::Writes,
}

impl<T, I: VmAdapterInterface<T>> AdapterRuntimeContextWom<T, I> {
    /// Leave `to_pc` as `None` to allow the adapter to decide the `to_pc` automatically.
    pub fn without_pc_fp(writes: impl Into<I::Writes>) -> Self {
        Self {
            to_pc: None,
            to_fp: None,
            writes: writes.into(),
        }
    }
}

/// Core chip trait for Womir VM with frame pointer support
pub trait VmCoreChipWom<F, I: VmAdapterInterface<F>> {
    /// Minimum data that must be recorded to be able to generate trace for one row of
    /// `PrimitiveAir`.
    type Record: Send + Serialize + DeserializeOwned;
    /// The primitive AIR with main constraints that do not depend on memory and other
    /// architecture-specifics.
    type Air: BaseAirWithPublicValues<F> + Clone;

    #[allow(clippy::type_complexity)]
    fn execute_instruction(
        &self,
        instruction: &Instruction<F>,
        from_pc: u32,
        from_fp: u32,
        reads: I::Reads,
    ) -> ResultVm<(AdapterRuntimeContextWom<F, I>, Self::Record)>;

    fn get_opcode_name(&self, opcode: usize) -> String;

    /// Populates `row_slice` with values corresponding to `record`.
    /// The provided `row_slice` will have length equal to `self.air().width()`.
    /// This function will be called for each row in the trace which is being used, and all other
    /// rows in the trace will be filled with zeroes.
    fn generate_trace_row(&self, row_slice: &mut [F], record: Self::Record);

    /// Returns a list of public values to publish.
    fn generate_public_values(&self) -> Vec<F> {
        vec![]
    }

    fn air(&self) -> &Self::Air;

    /// Finalize the trace, especially the padded rows if the all-zero rows don't satisfy the
    /// constraints. This is done **after** records are consumed and the trace matrix is
    /// generated. Most implementations should just leave the default implementation if padding
    /// with rows of all 0s satisfies the constraints.
    fn finalize(&self, _trace: &mut RowMajorMatrix<F>, _num_records: usize) {
        // do nothing by default
    }
}

// ============ Trait Implementations ============

impl<F, A, M> InstructionExecutorTrait<F> for VmChipWrapperWom<F, A, M>
where
    F: PrimeField32,
    A: VmAdapterChipWom<F> + Send + Sync,
    M: VmCoreChipWom<F, A::Interface> + Send + Sync,
{
    fn execute(
        &mut self,
        memory: &mut MemoryController<F>,
        instruction: &Instruction<F>,
        from_state: ExecutionState<u32>,
    ) -> ResultVm<ExecutionState<u32>> {
        let mut fp = self.fp.lock().unwrap();
        println!("Executing inside VmChipWrapperWom instruction: {instruction:?}, from_state: {from_state:?}, fp: {fp}");
        let (reads, read_record) = self.adapter.preprocess(memory, *fp, instruction)?;
        let (output, core_record) =
            self.core
                .execute_instruction(instruction, from_state.pc, *fp, reads)?;
        let (to_state, to_fp, write_record) = self.adapter.postprocess(
            memory,
            instruction,
            from_state,
            FrameState::new(from_state.pc, *fp),
            output,
            &read_record,
        )?;
        *fp = to_fp;
        self.records.push((read_record, write_record, core_record));
        Ok(to_state)
    }

    fn get_opcode_name(&self, opcode: usize) -> String {
        self.core.get_opcode_name(opcode)
    }
}

impl<SC, A, C> Chip<SC> for VmChipWrapperWom<Val<SC>, A, C>
where
    SC: StarkGenericConfig,
    Val<SC>: PrimeField32,
    A: VmAdapterChipWom<Val<SC>> + Send + Sync,
    C: VmCoreChipWom<Val<SC>, A::Interface> + Send + Sync,
    A::Air: Send + Sync + 'static,
    A::Air: VmAdapterAir<SymbolicRapBuilder<Val<SC>>> + ColumnsAir<Val<SC>>,
    A::Air: for<'a> VmAdapterAir<DebugConstraintBuilder<'a, SC>>,
    C::Air: Send + Sync + 'static,
    C::Air: VmCoreAir<
            SymbolicRapBuilder<Val<SC>>,
            <A::Air as VmAdapterAir<SymbolicRapBuilder<Val<SC>>>>::Interface,
        > + ColumnsAir<Val<SC>>,
    C::Air: for<'a> VmCoreAir<
        DebugConstraintBuilder<'a, SC>,
        <A::Air as VmAdapterAir<DebugConstraintBuilder<'a, SC>>>::Interface,
    >,
{
    fn air(&self) -> AirRef<SC> {
        let air: VmAirWrapper<A::Air, C::Air> = VmAirWrapper {
            adapter: self.adapter.air().clone(),
            core: self.core.air().clone(),
        };
        Arc::new(air)
    }

    fn generate_air_proof_input(self) -> AirProofInput<SC> {
        let num_records = self.records.len();
        let height = next_power_of_two_or_zero(num_records);
        let core_width = self.core.air().width();
        let adapter_width = self.adapter.air().width();
        let width = core_width + adapter_width;
        let mut values = Val::<SC>::zero_vec(height * width);

        let memory = self.offline_memory.lock().unwrap();

        // This zip only goes through records.
        // The padding rows between records.len()..height are filled with zeros.
        values
            .par_chunks_mut(width)
            .zip(self.records.into_par_iter())
            .for_each(|(row_slice, record)| {
                let (adapter_row, core_row) = row_slice.split_at_mut(adapter_width);
                self.adapter
                    .generate_trace_row(adapter_row, record.0, record.1, &memory);
                self.core.generate_trace_row(core_row, record.2);
            });

        let mut trace = RowMajorMatrix::new(values, width);
        self.core.finalize(&mut trace, num_records);

        AirProofInput::simple(trace, self.core.generate_public_values())
    }
}

impl<F, A, M> ChipUsageGetter for VmChipWrapperWom<F, A, M>
where
    A: VmAdapterChipWom<F> + Sync,
    M: VmCoreChipWom<F, A::Interface> + Sync,
{
    fn air_name(&self) -> String {
        format!(
            "<{},{}>",
            get_air_name(self.adapter.air()),
            get_air_name(self.core.air())
        )
    }
    fn current_trace_height(&self) -> usize {
        self.records.len()
    }
    fn trace_width(&self) -> usize {
        self.adapter.air().width() + self.core.air().width()
    }
}
